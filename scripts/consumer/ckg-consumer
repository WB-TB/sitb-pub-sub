#!/bin/bash
#
# ckg-consumer        CKG Consumer Service
#
# chkconfig: 2345 90 10
# description: CKG Consumer service for processing messages from Pub/Sub
# processname: ckg-consumer
# pidfile: /var/run/ckg-consumer.pid

### BEGIN INIT INFO
# Provides:          ckg-consumer
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: CKG Consumer Service
# Description:       CKG Consumer service for processing messages from Pub/Sub
### END INIT INFO

# Source function library
if [ -f /etc/rc.d/init.d/functions ]; then
    . /etc/rc.d/init.d/functions
elif [ -f /lib/lsb/init-functions ]; then
    . /lib/lsb/init-functions
fi

# Configuration
NAME="ckg-consumer"
DESC="CKG Consumer Service"
TARGET_DIR="/opt/sitb-ckg"
CONSUMER_SCRIPT="$TARGET_DIR/scripts/consumer/run-consumer.sh"
PIDFILE="/var/run/${NAME}.pid"
LOGFILE="/var/log/${NAME}.log"

# Check if consumer script exists
if [ ! -f "$CONSUMER_SCRIPT" ]; then
    echo "Error: Consumer script not found: $CONSUMER_SCRIPT"
    exit 1
fi

# Make sure the script is executable
chmod +x "$CONSUMER_SCRIPT" 2>/dev/null

# Get process ID
get_pid() {
    if [ -f "$PIDFILE" ]; then
        cat "$PIDFILE"
    fi
}

# Check if process is running
is_running() {
    local pid=$(get_pid)
    if [ -n "$pid" ]; then
        if ps -p "$pid" > /dev/null 2>&1; then
            return 0
        fi
    fi
    return 1
}

# Get all running consumer processes (including those not in PIDFILE)
get_all_consumer_pids() {
    # Find all processes running the consumer script
    ps aux | grep -E "(run-consumer\.sh|consumer\.php)" | grep -v grep | awk '{print $2}'
}

# Count running consumer processes
count_running_consumers() {
    local count=$(get_all_consumer_pids | wc -l)
    echo $count
}

# Start the service
do_start() {
    echo -n "Starting $DESC: "
    
    # Check for any existing consumer processes
    local existing_pids=$(get_all_consumer_pids)
    if [ -n "$existing_pids" ]; then
        local pid_count=$(echo "$existing_pids" | wc -w)
        echo ""
        echo "Error: Found $pid_count consumer process(es) already running:"
        for pid in $existing_pids; do
            echo "  - PID: $pid"
        done
        echo ""
        echo "Please use 'stop' or 'restart' command instead."
        return 1
    fi
    
    # Start the consumer in background
    nohup "$CONSUMER_SCRIPT" >> "$LOGFILE" 2>&1 &
    local pid=$!
    
    # Save PID
    echo $pid > "$PIDFILE"
    
    # Give it a moment to start
    sleep 1
    
    if is_running; then
        echo "started (PID: $pid)"
        return 0
    else
        echo "failed to start"
        rm -f "$PIDFILE"
        return 1
    fi
}

# Stop the service
do_stop() {
    echo -n "Stopping $DESC: "
    
    # Get all consumer processes
    local all_pids=$(get_all_consumer_pids)
    
    if [ -z "$all_pids" ]; then
        echo "not running"
        rm -f "$PIDFILE"
        return 0
    fi
    
    local pid_count=$(echo "$all_pids" | wc -w)
    echo "found $pid_count running process(es), stopping... "
    
    # Try graceful shutdown first for all processes
    for pid in $all_pids; do
        kill -TERM "$pid" 2>/dev/null
    done
    
    # Wait for processes to terminate
    local count=0
    while [ $count -lt 30 ]; do
        local remaining=$(get_all_consumer_pids)
        if [ -z "$remaining" ]; then
            break
        fi
        sleep 1
        count=$((count + 1))
    done
    
    # Force kill any remaining processes
    local remaining=$(get_all_consumer_pids)
    if [ -n "$remaining" ]; then
        echo -n "force killing remaining processes... "
        for pid in $remaining; do
            kill -KILL "$pid" 2>/dev/null
        done
        sleep 1
    fi
    
    # Final check
    local final_remaining=$(get_all_consumer_pids)
    if [ -n "$final_remaining" ]; then
        echo "failed to stop some processes"
        return 1
    else
        echo "stopped"
        rm -f "$PIDFILE"
        return 0
    fi
}

# Restart the service
do_restart() {
    echo "Restarting $DESC: "
    do_stop
    sleep 2
    do_start
}

# Reload the service
do_reload() {
    echo -n "Reloading $DESC: "
    
    if ! is_running; then
        echo "not running"
        return 1
    fi
    
    local pid=$(get_pid)
    kill -HUP "$pid" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "reloaded"
        return 0
    else
        echo "failed to reload"
        return 1
    fi
}

# Get service status
do_status() {
    local all_pids=$(get_all_consumer_pids)
    
    if [ -n "$all_pids" ]; then
        local pid_count=$(echo "$all_pids" | wc -w)
        if [ $pid_count -eq 1 ]; then
            echo "$DESC is running (PID: $all_pids)"
        else
            echo "$DESC has $pid_count running process(es):"
            for pid in $all_pids; do
                echo "  - PID: $pid"
            done
        fi
        return 0
    else
        echo "$DESC is not running"
        return 1
    fi
}

# Main script logic
case "$1" in
    start)
        do_start
        exit $?
        ;;
    stop)
        do_stop
        exit $?
        ;;
    restart)
        do_restart
        exit $?
        ;;
    reload|force-reload)
        do_reload
        exit $?
        ;;
    status)
        do_status
        exit $?
        ;;
    cleanup)
        echo "Cleaning up all consumer processes..."
        local all_pids=$(get_all_consumer_pids)
        if [ -n "$all_pids" ]; then
            echo "Found $(echo "$all_pids" | wc -w) consumer process(es)"
            for pid in $all_pids; do
                echo "Killing PID $pid..."
                kill -TERM "$pid" 2>/dev/null
            done
            sleep 2
            # Force kill remaining
            for pid in $(get_all_consumer_pids); do
                echo "Force killing PID $pid..."
                kill -KILL "$pid" 2>/dev/null
            done
            rm -f "$PIDFILE"
            echo "Cleanup complete"
        else
            echo "No consumer processes found"
        fi
        exit 0
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|reload|force-reload|status|cleanup}"
        exit 1
        ;;
esac

exit 0
